package bitc.full502.lostandfound.ui

import android.Manifest
import android.app.Activity
import android.app.DatePickerDialog
import android.content.Intent
import android.icu.text.SimpleDateFormat
import android.location.LocationManager
import android.net.Uri
import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.AdapterView
import android.widget.ArrayAdapter
import android.widget.Toast
import androidx.activity.enableEdgeToEdge
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.PickVisualMediaRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.core.content.FileProvider
import androidx.core.view.ViewCompat
import androidx.core.view.WindowInsetsCompat
import androidx.lifecycle.lifecycleScope
import bitc.full502.lostandfound.R
import bitc.full502.lostandfound.data.api.ApiClient
import bitc.full502.lostandfound.data.api.BoardService
import bitc.full502.lostandfound.data.api.GeoService
import bitc.full502.lostandfound.data.api.ReverseGeoService
import bitc.full502.lostandfound.data.model.BoardData
import bitc.full502.lostandfound.databinding.ActivityLostWriteBinding
import bitc.full502.lostandfound.map.MapHelper // ‚úÖ ÏÇ¨Ïö©
import bitc.full502.lostandfound.storage.TokenManager
import bitc.full502.lostandfound.util.Constants
import bitc.full502.lostandfound.util.Constants.EXTRA_BOARD_DATA
import bitc.full502.lostandfound.util.Constants.EXTRA_BOARD_ID
import bitc.full502.lostandfound.util.Constants.EXTRA_MODE
import bitc.full502.lostandfound.util.Constants.MODE_EDIT
import bitc.full502.lostandfound.util.Formatter
import bitc.full502.lostandfound.util.GeocodingConstants
import bitc.full502.lostandfound.util.ReverseGeocoder
import com.google.gson.Gson
import com.naver.maps.geometry.LatLng
import com.naver.maps.map.CameraAnimation
import com.naver.maps.map.CameraPosition
import com.naver.maps.map.CameraUpdate
import com.naver.maps.map.NaverMap
import com.naver.maps.map.overlay.Marker
import kotlinx.coroutines.launch
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.MultipartBody
import okhttp3.RequestBody
import okhttp3.RequestBody.Companion.toRequestBody
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import java.io.File
import java.util.Locale

class LostWriteActivity : AppCompatActivity() {

    private var isEditMode = false
    private var editingBoard: BoardData? = null
    private var editingBoardId: Long = -1L
    private val REQ_LOCATION = 2001
    private lateinit var mapHelper: MapHelper
    private val tokenManager: TokenManager by lazy { TokenManager(this) }
    private val binding by lazy { ActivityLostWriteBinding.inflate(layoutInflater) }
    private val reverseGeo by lazy { ApiClient.createJsonService(GeocodingConstants.REVERSE_GEOCODE_URL, ReverseGeoService::class.java) }
    private val geo by lazy { ApiClient.createJsonService(GeocodingConstants.GEOCODE_URL, GeoService::class.java) }
    private val api by lazy { ApiClient.createJsonService(Constants.BASE_URL, BoardService::class.java) }
    private lateinit var addressLauncher: ActivityResultLauncher<Intent>
    private val fileProviderAuthority by lazy { "$packageName.fileprovider" }
    private var pendingCameraImageUri: Uri? = null
    private var uploadImageUri: Uri? = null
    private val pickMedia = registerForActivityResult(ActivityResultContracts.PickVisualMedia()) { uri ->
        if (uri != null) showImage(uri)
    }
    private val takePicture = registerForActivityResult(ActivityResultContracts.TakePicture()) { success ->
        if (success) {
            pendingCameraImageUri?.let { showImage(it) }
        } else {
            cleanupPendingCameraFile()
        }
    }
    private val requestCameraPermission =
        registerForActivityResult(ActivityResultContracts.RequestPermission()) { granted ->
            if (granted) launchCamera()
            else Toast.makeText(this, "Ïπ¥Î©îÎùº Í∂åÌïú ÏÑ§Ï†ïÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.", Toast.LENGTH_SHORT).show()
        }
    private var naverMap: NaverMap? = null
    private val mapMarker by lazy { Marker() }
    private var selectedLatLng: LatLng? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContentView(binding.root)

        // WindowInsets Ï†ÅÏö©
        ViewCompat.setOnApplyWindowInsetsListener(binding.main) { v, insets ->
            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
            v.setPadding(systemBars.left, systemBars.top, systemBars.right, systemBars.bottom)
            insets
        }
        val adapter = ArrayAdapter.createFromResource(
            this, R.array.category_array, R.layout.spinner_item
        )
        adapter.setDropDownViewResource(R.layout.spinner_dropdown_item)
        binding.selectCategory.adapter = adapter

        setupUi()

        mapHelper = MapHelper(
            activity = this,
            fragmentManager = supportFragmentManager,
            mapContainerId = R.id.map_fragment,
            ncpApiKey = GeocodingConstants.NCP_KEY_ID, // üîÅ ÏßÄÎèÑ SDKÏö© Client IDÎ°ú ÍµêÏ≤¥
            locationRequestCode = REQ_LOCATION
        )

        mapHelper.init { map ->
            naverMap = map
            setupMapListeners(map) // ÏßÄÎèÑ Ï§ÄÎπÑ ÌõÑ Î¶¨Ïä§ÎÑà Ïó∞Í≤∞
            editingBoard?.let { fillFormFromBoard(it) }
        }

        addressLauncher = registerForActivityResult(
            ActivityResultContracts.StartActivityForResult()
        ) { result ->
            if (result.resultCode == RESULT_OK) {
                val data = result.data
                val road = data?.getStringExtra("roadAddress")
                val zonecode = data?.getStringExtra("zonecode")
                binding.etAddress.setText("$road ($zonecode)")
                geocodeAddress("$road ($zonecode)")
            }
        }

        val mode = intent.getStringExtra(EXTRA_MODE)
        if (mode == MODE_EDIT) {
            val board = intent.getParcelableExtra<BoardData>(EXTRA_BOARD_DATA)
            val boardId = intent.getLongExtra(EXTRA_BOARD_ID, -1L)
            if (board != null && boardId > 0) {
                editingBoard = board
                editingBoardId = boardId
                isEditMode = true
                enterEditMode(board, boardId)
            }
        }
    }

    // ============================================================
    // UI Î¶¨Ïä§ÎÑà Î∞è Ï¥àÍ∏∞Ìôî Î™®Ïùå
    // ============================================================
    private fun setupUi() {
        binding.topBar.btnBack.setOnClickListener { onBackPressedDispatcher.onBackPressed() }
        binding.imageRegistSlot.setOnClickListener { showPickOrCameraSheet() }
        binding.imagePlaceholder.setOnClickListener { showPickOrCameraSheet() }
        binding.selectCategory.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
            override fun onItemSelected(p: AdapterView<*>?, v: View?, position: Int, id: Long) {}
            override fun onNothingSelected(parent: AdapterView<*>?) {}
        }
        binding.lostDate.setOnClickListener { showDateTimePicker() }
        binding.tilAddress.setEndIconOnClickListener {
            val intent = Intent(this, AddressSearchActivity::class.java)
            addressLauncher.launch(intent)
        }
        // Îì±Î°ù
        binding.incRegistBar.btnRegister.setOnClickListener { onClickRegister() }
    }

    // ============================================================
    // Îì±Î°ù Î≤ÑÌäº ÌÅ¥Î¶≠ Ìï∏Îì§Îü¨
    // ============================================================
    private fun onClickRegister() {
        val lostDateRaw = binding.lostDate.text?.toString()?.trim().orEmpty()
        if (lostDateRaw.isBlank()) {
            Toast.makeText(this, "ÎÇ†ÏßúÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.", Toast.LENGTH_SHORT).show()
            return
        }

        val point = selectedLatLng ?: run {
            Toast.makeText(this, "ÏßÄÎèÑÎ•º Í∏∏Í≤å ÎàåÎü¨ ÏúÑÏπòÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.", Toast.LENGTH_SHORT).show()
            return
        }
        val lostDateStr = Formatter.displayToIsoSecondsOrNull(lostDateRaw)
        if (lostDateStr == null) {
            Toast.makeText(this, "ÎÇ†Ïßú ÌòïÏãùÏù¥ Ïò¨Î∞îÎ•¥ÏßÄ ÏïäÏäµÎãàÎã§.", Toast.LENGTH_SHORT).show()
            return
        }
        val categoryCode = binding.selectCategory.selectedItemPosition
        val lostProductName = binding.tvLostProductName.text?.toString()?.trim().orEmpty()
        val lostPerson = binding.lostPersonName.text?.toString()?.trim().orEmpty()
        val lat = point.latitude
        val lng = point.longitude
        val fullAddress = listOf(
            binding.etAddress.text?.toString()?.trim().orEmpty(),
            binding.detailAddress.text?.toString()?.trim().orEmpty()
        ).filter { it.isNotBlank() }.joinToString(" ")
        val detailAddress =  binding.detailAddress.text?.toString()?.trim().orEmpty()
        val contentText = binding.comments.text?.toString()?.trim().orEmpty()
        run {
            var ok = true
            if (lostProductName.isBlank()) {
                ok = false; Toast.makeText(this, "Î∂ÑÏã§Î¨ºÎ™ÖÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.", Toast.LENGTH_SHORT).show()
            }
            if (fullAddress.isBlank()) {
                ok = false; Toast.makeText(this, "Ï£ºÏÜåÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.", Toast.LENGTH_SHORT).show()
            }
            if (!ok) return
        }
        val filePart: MultipartBody.Part? = try {
            uploadImageUri?.let { uri ->
                val mime = contentResolver.getType(uri) ?: "application/octet-stream"
                val rb = object : RequestBody() {
                    override fun contentType() = mime.toMediaType()
                    override fun writeTo(sink: okio.BufferedSink) {
                        contentResolver.openInputStream(uri)?.use { input ->
                            input.copyTo(sink.outputStream())
                        } ?: throw IllegalStateException("Ïù¥ÎØ∏ÏßÄ Ïä§Ìä∏Î¶ºÏùÑ Ïó¥ Ïàò ÏóÜÏäµÎãàÎã§.")
                    }
                }
                MultipartBody.Part.createFormData("file", "upload.jpg", rb)
            }
        } catch (e: Throwable) {
            Toast.makeText(this, "ÏÇ¨ÏßÑ Ï§ÄÎπÑ Ï§ë Ïò§Î•ò: ", Toast.LENGTH_SHORT).show()
            null
        }

        val dto = BoardData(
            idx = 0L,
            userId = "",
            categoryId = categoryCode,
            title = lostProductName,
            imgUrl = "",
            ownerName = lostPerson.ifBlank { "Ïù¥Î¶ÑÏóÜÏùå" },
            description = contentText,
            eventDate = lostDateStr,
            eventLat = lat,
            eventLng = lng,
            eventDetail = detailAddress,
            storageLocation = "ÎØ∏Î≥¥Í¥ÄÏÉÅÌÉú - Î∂ÑÏã§Î¨º",
            type = "LOST",
            status = "PENDING",
            createDate = null
        )
        val dtoPart = Gson().toJson(dto).toRequestBody("text/plain; charset=UTF-8".toMediaType())

        val token = tokenManager.getToken().orEmpty()
        if (token.isBlank()) {
            Toast.makeText(this, "Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§.", Toast.LENGTH_SHORT).show()
            return
        }

        api.insertBoard("Bearer $token", dtoPart, filePart)
            .enqueue(object : Callback<BoardData> {
                override fun onResponse(call: Call<BoardData>, resp: Response<BoardData>) {
                    val body = resp.body()
                    val ok = resp.isSuccessful && body != null && (body.idx ?: 0L) > 0L
                    if (ok) {
                        Toast.makeText(this@LostWriteActivity, "Îì±Î°ù ÏÑ±Í≥µ!", Toast.LENGTH_SHORT).show()
                        finish()
                    } else {
                        Toast.makeText(this@LostWriteActivity, "Îì±Î°ù Ïã§Ìå®", Toast.LENGTH_SHORT).show()
                    }
                }

                override fun onFailure(call: Call<BoardData>, t: Throwable) {
                    Toast.makeText(this@LostWriteActivity, "ÌÜµÏã† Ïã§Ìå®: ${t.message}", Toast.LENGTH_SHORT).show()
                }
            })
    }

    // ============================================================
    // ÏÇ¨ÏßÑ ÏÑ†ÌÉù/Ï¥¨ÏòÅ
    // ============================================================
    private fun showPickOrCameraSheet() {
        val items = if (isEditMode) {
            arrayOf("ÏÇ¨ÏßÑ ÏÑ†ÌÉù", "Ïπ¥Î©îÎùº Ï¥¨ÏòÅ") // ‚Üê ÏàòÏ†ï Î™®Îìú: 2Î≤à Ìï≠Î™© Ï†úÍ±∞
        } else {
            arrayOf("ÏÇ¨ÏßÑ ÏÑ†ÌÉù", "Ïπ¥Î©îÎùº Ï¥¨ÏòÅ", "ÏÇ¨ÏßÑ ÏÑ†ÌÉù ÏïàÌï®")
        }

        AlertDialog.Builder(this)
            .setTitle(if (isEditMode) "ÏÇ¨ÏßÑ Î≥ÄÍ≤Ω" else "ÏÇ¨ÏßÑ Îì±Î°ù")
            .setItems(items) { _, which ->
                when (items[which]) { // Ïù∏Îç±Ïä§ ÎßêÍ≥† 'ÌÖçÏä§Ìä∏'Î°ú Î∂ÑÍ∏∞
                    "ÏÇ¨ÏßÑ ÏÑ†ÌÉù" -> launchPhotoPicker()
                    "Ïπ¥Î©îÎùº Ï¥¨ÏòÅ" -> ensureCameraPermissionThenLaunch()
                    "ÏÇ¨ÏßÑ ÏÑ†ÌÉù ÏïàÌï®" -> clearSelectedImage()
                }
            }
            .show()
    }

    // Ïï®Î≤îÏóêÏÑú ÏÑ†ÌÉù
    private fun launchPhotoPicker() {
        pickMedia.launch(PickVisualMediaRequest(ActivityResultContracts.PickVisualMedia.ImageOnly))
    }

    // Ïπ¥Î©îÎùº Í∂åÌïú ÌôïÏù∏ ÌõÑ Ï¥¨ÏòÅ
    private fun ensureCameraPermissionThenLaunch() {
        requestCameraPermission.launch(Manifest.permission.CAMERA)
    }

    // ÏÇ¨ÏßÑ ÏÑ†ÌÉù Ìï¥Ï†ú
    private fun clearSelectedImage() {
        uploadImageUri = null
        binding.ivRegisted.setImageDrawable(null)
        binding.imagePlaceholder.visibility = View.VISIBLE
    }

    // Ïπ¥Î©îÎùº Ïã§Ìñâ: Ï∫êÏãúÏóê ÏûÑÏãú ÌååÏùº ÏÉùÏÑ± ÌõÑ Ï¥¨ÏòÅ Í≤∞Í≥ºÎ•º Ìï¥Îãπ URIÏóê Í∏∞Î°ù
    private fun launchCamera() {
        val uri = createTempImageUriInCache()
        pendingCameraImageUri = uri
        takePicture.launch(uri)
    }

    // Ïù¥ÎØ∏ÏßÄ ÏÑ†ÌÉù/Ï¥¨ÏòÅ ÌõÑ ÎØ∏Î¶¨Î≥¥Í∏∞
    private fun showImage(uri: Uri) {
        uploadImageUri = uri
        binding.ivRegisted.setImageURI(uri)
        binding.imagePlaceholder.visibility = View.GONE
    }

    // cache/images/ Ïóê ÏûÑÏãú ÌååÏùº ÏÉùÏÑ± + FileProviderÎ°ú content URI ÌöçÎìù
    private fun createTempImageUriInCache(): Uri {
        val imagesDir = File(cacheDir, "images").apply { mkdirs() }
        val fileName = "LostFound_${timestamp()}.jpg"
        val file = File(imagesDir, fileName).apply {
            if (exists()) delete()
            createNewFile()
        }
        return FileProvider.getUriForFile(this, fileProviderAuthority, file)
    }

    // Ï¥¨ÏòÅ Ï∑®ÏÜå Ïãú ÏûÑÏãú URIÎßå Ï¥àÍ∏∞Ìôî
    private fun cleanupPendingCameraFile() {
        pendingCameraImageUri = null
    }

    // Ï¥¨ÏòÅ ÌååÏùº Ïù¥Î¶Ñ Í∑úÍ≤©
    private fun timestamp(): String =
        SimpleDateFormat("yyyyMMdd_HHmmss_SSS", Locale.getDefault()).format(System.currentTimeMillis())

    // ============================================================
    // ÎÇ†Ïßú ÏÑ†ÌÉù Îã§Ïù¥ÏñºÎ°úÍ∑∏
    // ============================================================
    private fun showDateTimePicker() {
        // Í∏∞Ï§Ä: ÌòÑÏû¨ ÏãúÍ∞Å
        val now = java.util.Calendar.getInstance()
        val y = now.get(java.util.Calendar.YEAR)
        val m = now.get(java.util.Calendar.MONTH)
        val d = now.get(java.util.Calendar.DAY_OF_MONTH)
        val H = now.get(java.util.Calendar.HOUR_OF_DAY)
        val M = now.get(java.util.Calendar.MINUTE)

        // 1) ÎÇ†Ïßú ÏÑ†ÌÉù(Ïä§ÌîºÎÑà Ïä§ÌÉÄÏùº Ïú†ÏßÄ)
        val themedCtx = androidx.appcompat.view.ContextThemeWrapper(this, R.style.SpinnerDatePickerDialog)
        val dateDialog = android.app.DatePickerDialog(
            themedCtx,
            { _, year, monthZero, dayOfMonth ->
                // 2) ÎÇ†Ïßú ÏÑ†ÌÉù ÌõÑ ÏãúÍ∞Ñ ÏÑ†ÌÉù
                showTimePicker(year, monthZero, dayOfMonth)
            },
            y, m, d
        )
        dateDialog.datePicker.maxDate = now.timeInMillis  // ÎÇ†Ïßú ÏûêÏ≤¥Îäî Ïò§ÎäòÍπåÏßÄ
        dateDialog.show()
        dateDialog.getButton(DatePickerDialog.BUTTON_POSITIVE)?.apply {
            text = "Îã§Ïùå"; isAllCaps = false
            setTextColor(ContextCompat.getColor(this@LostWriteActivity, R.color.black))
        }
        dateDialog.getButton(DatePickerDialog.BUTTON_NEGATIVE)?.apply {
            text = "Ï∑®ÏÜå"; isAllCaps = false
            setTextColor(ContextCompat.getColor(this@LostWriteActivity, R.color.black))
        }
    }
    private fun showTimePicker(year: Int, monthZero: Int, day: Int) {
        val now = java.util.Calendar.getInstance()
        val initHour = now.get(java.util.Calendar.HOUR_OF_DAY)
        val initMinute = now.get(java.util.Calendar.MINUTE)
        val is24Hour = android.text.format.DateFormat.is24HourFormat(this)
        val timeDialog = android.app.TimePickerDialog(
            this,
            { _, hourOfDay, minute ->
                // ÏµúÏ¢Ö Í≤ÄÏ¶ù: Ïò§Îäò ÎÇ†ÏßúÎ•º ÏÑ†ÌÉùÌñàÍ≥†, ÏãúÍ∞ÑÏù¥ ÎØ∏ÎûòÎ©¥ ÌòÑÏû¨ ÏãúÍ∞ÅÏúºÎ°ú ÌÅ¥Îû®ÌîÑ
                val selected = java.util.Calendar.getInstance().apply {
                    set(java.util.Calendar.YEAR, year)
                    set(java.util.Calendar.MONTH, monthZero)
                    set(java.util.Calendar.DAY_OF_MONTH, day)
                    set(java.util.Calendar.HOUR_OF_DAY, hourOfDay)
                    set(java.util.Calendar.MINUTE, minute)
                    set(java.util.Calendar.SECOND, 0)
                    set(java.util.Calendar.MILLISECOND, 0)
                }
                val nowCal = java.util.Calendar.getInstance()
                if (selected.after(nowCal)) {
                    // ÎØ∏Îûò Î∂àÌóà: ÌòÑÏû¨ ÏãúÍ∞ÅÏúºÎ°ú Ï°∞Ï†ï
                    selected.timeInMillis = nowCal.timeInMillis
                }

                val y = selected.get(java.util.Calendar.YEAR)
                val m = selected.get(java.util.Calendar.MONTH) + 1
                val d = selected.get(java.util.Calendar.DAY_OF_MONTH)
                val H = selected.get(java.util.Calendar.HOUR_OF_DAY)
                val M = selected.get(java.util.Calendar.MINUTE)

                // ÏûÖÎ†• ÌïÑÎìúÏóêÎäî "yyyy-MM-dd HH:mm"
                val display = String.format(Locale.getDefault(), "%04dÎÖÑ %02dÏõî %02dÏùº %02dÏãú %02dÎ∂Ñ", y, m, d, H, M)
                binding.lostDate.setText(display)
            },
            initHour,
            initMinute,
            is24Hour
        )

        timeDialog.setTitle("ÏãúÍ∞Ñ ÏÑ†ÌÉù")
        timeDialog.show()
    }


    // ============================================================
    // ÏßÄÎèÑ: Î°±ÌÅ¥Î¶≠ ‚Üí ÎßàÏª§/Ï£ºÏÜå Î∞òÏòÅ
    // ============================================================
    private fun setupMapListeners(map: NaverMap) {
        map.setOnMapLongClickListener { _, coord ->
            selectedLatLng = coord
            mapMarker.position = coord
            mapMarker.map = map

            ReverseGeocoder.fetchAddress(reverseGeo, coord.latitude, coord.longitude) { base ->
                val addressLine = base ?: "Ï£ºÏÜå ÎØ∏ÌôïÏù∏"
                binding.etAddress.setText(addressLine)
            }

            map.moveCamera(
                CameraUpdate.toCameraPosition(CameraPosition(coord, 16.0))
                    .animate(CameraAnimation.Fly, 800L)
            )
        }
    }

    // Ï£ºÏÜå ‚Üí Ï¢åÌëú
    private fun geocodeAddress(query: String) {
        lifecycleScope.launch {
            try {
                val res = geo.getCoordinateFromAddress(
                    keyId = GeocodingConstants.NCP_KEY_ID,
                    key = GeocodingConstants.NCP_KEY,
                    query = query
                )
                val first = res.addresses.firstOrNull()
                if (first == null) {
                    Toast.makeText(this@LostWriteActivity, "Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏäµÎãàÎã§.", Toast.LENGTH_SHORT).show()
                    return@launch
                }
                applyGeocodeResult(first)
            } catch (e: retrofit2.HttpException) {
                val code = e.code()
                val errBody = e.response()?.errorBody()?.string()
                Log.e("NCP-GEOCODE", "HTTP $code body=$errBody", e)
                Toast.makeText(this@LostWriteActivity, "Ï£ºÏÜå Í≤ÄÏÉâ Ïã§Ìå®", Toast.LENGTH_SHORT).show()
            } catch (e: Exception) {
                Log.e("NCP-GEOCODE", "onError", e) // UnknownHost/SSLHandshake/Timeout Îì±
                Toast.makeText(this@LostWriteActivity, "Ï£ºÏÜå Í≤ÄÏÉâ Ïã§Ìå®:", Toast.LENGTH_SHORT).show()
            }
        }
    }

    // ÏßÄÏò§ÏΩîÎî© Í≤∞Í≥º Î∞òÏòÅ
    private fun applyGeocodeResult(addr: bitc.full502.lostandfound.data.model.Address) {
        val lat = addr.latDouble
        val lng = addr.lngDouble
        if (lat == null || lng == null) {
            Toast.makeText(this, "Ï¢åÌëú Î≥ÄÌôò Ïã§Ìå®(ÏúÑÎèÑ/Í≤ΩÎèÑ ÏóÜÏùå)", Toast.LENGTH_SHORT).show()
            return
        }

        val label = when {
            addr.roadAddress.isNotBlank() -> addr.roadAddress
            addr.jibunAddress.isNotBlank() -> addr.jibunAddress
            else -> "Ï£ºÏÜå ÎØ∏ÌôïÏù∏"
        }
        binding.etAddress.setText(label)

        val pos = LatLng(lat, lng)
        selectedLatLng = pos
        mapMarker.position = pos
        mapMarker.map = naverMap

        naverMap?.moveCamera(
            CameraUpdate.toCameraPosition(CameraPosition(pos, 16.0))
                .animate(CameraAnimation.Fly, 800L)
        )
    }

    override fun onRequestPermissionsResult(
        requestCode: Int, permissions: Array<out String>, grantResults: IntArray
    ) {
        mapHelper.onRequestPermissionsResult(requestCode, permissions, grantResults)
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
    }

    private fun enterEditMode(board: BoardData, boardId: Long) {
        // 2) ÌèºÏùÑ Í∏∞Ï°¥ ÎÇ¥Ïö©ÏúºÎ°ú Ï±ÑÏõÄ
        fillFormFromBoard(board)
        // 3) "Îì±Î°ùÌïòÍ∏∞" ÌÅ¥Î¶≠ Ïãú PUT Ìò∏Ï∂úÎ°ú Ïó∞Í≤∞
        binding.incRegistBar.btnRegister.setOnClickListener { submitUpdate(boardId) }
    }

    private fun fillFormFromBoard(b: BoardData) {

        binding.tvLostProductName.setText(b.title.orEmpty())
        binding.lostPersonName.setText(b.ownerName.orEmpty())
        binding.lostDate.setText(Formatter.isoToDisplayOrEmpty(b.eventDate))
//        val (baseAddr, detailAddr) = splitAddress(b.eventDetail)
//        binding.etAddress.setText(b.eventDetail)
        binding.detailAddress.setText(b.eventDetail)
        binding.comments.setText(b.description.orEmpty())
        // Ïπ¥ÌÖåÍ≥†Î¶¨: ÏÑúÎ≤Ñ categoryId ‚Üí Ïä§ÌîºÎÑà ÏÑ†ÌÉùÏúºÎ°ú Îß§Ìïë(Ìè¨ÏßÄÏÖò=ÏΩîÎìúÎ©¥ Í∑∏ÎåÄÎ°ú)
        runCatching {
            if (b.categoryId >= 0) binding.selectCategory.setSelection(b.categoryId)
        }
        val lat = b.eventLat
        val lng = b.eventLng
       ReverseGeocoder.fetchAddress(reverseGeo, lat, lng) { base ->
                if (!base.isNullOrBlank() && binding.etAddress.text.isNullOrBlank()) {
                    binding.etAddress.setText(base)
                }
            }
        if (lat != null && lng != null) {
            val pos = LatLng(lat, lng)
            selectedLatLng = pos
            mapMarker.position = pos
            mapMarker.map = naverMap
            naverMap?.moveCamera(
                CameraUpdate.toCameraPosition(CameraPosition(pos, 16.0))
                    .animate(CameraAnimation.Fly, 500L)
            )
        }
        // Ïù¥ÎØ∏ÏßÄ
        val url = b.imgUrl?.takeIf { it.isNotBlank() }?.let {
            if (it.startsWith("http")) it else Constants.IMAGE_BASE_URL + it
        }
        if (url != null) {
            // Í∏∞Ï°¥ Ïù¥ÎØ∏ÏßÄ Î≥¥Ïù¥Í∏∞ + placeholder Ïà®ÍπÄ
            binding.imagePlaceholder.visibility = View.GONE
            com.bumptech.glide.Glide.with(this)
                .load(url)
                .placeholder(R.drawable.img_placeholder)
                .error(R.drawable.img_placeholder)
                .into(binding.ivRegisted)
        } else {
            // Ïù¥ÎØ∏ÏßÄÍ∞Ä ÏóÜÏúºÎ©¥ Í∏∞Ï°¥ Î°úÏßÅ Í∑∏ÎåÄÎ°ú
            binding.ivRegisted.setImageDrawable(null)
            binding.imagePlaceholder.visibility = View.VISIBLE
        }
    }


    private fun nonBlankOrNull(s: CharSequence?) =
        s?.toString()?.trim()?.takeIf { it.isNotEmpty() }

    /** ÏÑúÎ≤Ñ Í∑úÏïΩ: nullÏù¥Î©¥ Ìï¥Îãπ ÌïÑÎìú ÎØ∏ÍµêÏ≤¥ */
    private fun buildUpdatePayload(): Pair<RequestBody, MultipartBody.Part?> {
        val origin = editingBoard
        val boardId = editingBoardId

        // ÌÖçÏä§Ìä∏ ÌïÑÎìú
        val title       = nonBlankOrNull(binding.tvLostProductName.text)
        val ownerName   = nonBlankOrNull(binding.lostPersonName.text)
        val description = nonBlankOrNull(binding.comments.text)

        // Ïπ¥ÌÖåÍ≥†Î¶¨: Ïä§ÌîºÎÑà Ìè¨ÏßÄÏÖò = ÏΩîÎìúÎùºÍ≥† Í∞ÄÏ†ï
        // Î≥ÄÍ≤Ω ÏóÜÏúºÎ©¥ nullÎ°ú(ÎØ∏ÍµêÏ≤¥), Î≥ÄÍ≤Ω ÎêòÏóàÏúºÎ©¥ ÏÉà Í∞í
        val selCat = binding.selectCategory.selectedItemPosition
        val categoryId: Int? =
            if (origin != null && selCat == origin.categoryId) null else selCat

        // Ï£ºÏÜå(Í∏∞Î≥∏ + ÏÉÅÏÑ∏)
        val base   = nonBlankOrNull(binding.etAddress.text)
        val detail = nonBlankOrNull(binding.detailAddress.text)
        val eventDetail = detail
        // ÎÇ†Ïßú: ÏûÖÎ†• ÏóÜÏúºÎ©¥ ÏõêÎ≥∏ Ïú†ÏßÄ(null Î≥¥ÎÉÑ ‚Üí ÎØ∏ÍµêÏ≤¥), ÏûÖÎ†• ÏûàÏúºÎ©¥ ISO-8601(Ï¥à)
        val pickedDateRaw = nonBlankOrNull(binding.lostDate.text)
        val eventDate: String? = Formatter.displayToIsoSecondsOrNull(pickedDateRaw)

        // Ï¢åÌëú: ÏÉà ÏÑ†ÌÉùÏù¥ ÏûàÏúºÎ©¥ ÏÉà Í∞í, ÏóÜÏúºÎ©¥ null(ÎØ∏ÍµêÏ≤¥)
        val latLng = selectedLatLng
        val eventLat: Double? = latLng?.latitude
        val eventLng: Double? = latLng?.longitude

        // type/status/storageLocation: ÏàòÏ†ï Ïïà ÌïúÎã§Î©¥ nullÎ°ú Îë†
        val type: String? = null
        val status: String? = null
        val storageLocation: String? = null


        // DTO Îßµ (null Ìè¨Ìï®: ÏÑúÎ≤ÑÍ∞Ä nullÏùÄ Î¨¥Ïãú)
        val dtoMap = mapOf(
            "idx"             to boardId,
            "title"           to title,
            "ownerName"       to ownerName,
            "description"     to description,
            "categoryId"      to categoryId,
            "eventDate"       to eventDate,
            "eventLat"        to eventLat,
            "eventLng"        to eventLng,
            "eventDetail"     to eventDetail,
            "imgUrl"          to null,
            "type"            to type,
            "status"          to status,
            "storageLocation" to storageLocation
        )

        val json = com.google.gson.Gson().toJson(dtoMap)
        val dtoPart = json.toRequestBody("application/json; charset=UTF-8".toMediaType())

        // ÌååÏùº Part (ÏÑ†ÌÉù)
        val filePart: MultipartBody.Part? = try {
            uploadImageUri?.let { uri ->
                val mime = contentResolver.getType(uri) ?: "application/octet-stream"
                val rb = object : RequestBody() {
                    override fun contentType() = mime.toMediaType()
                    override fun writeTo(sink: okio.BufferedSink) {
                        contentResolver.openInputStream(uri)?.use { input ->
                            input.copyTo(sink.outputStream())
                        } ?: throw IllegalStateException("Ïù¥ÎØ∏ÏßÄ Ïä§Ìä∏Î¶ºÏùÑ Ïó¥ Ïàò ÏóÜÏäµÎãàÎã§.")
                    }
                }
                MultipartBody.Part.createFormData("file", "upload.jpg", rb)
            }
        } catch (e: Throwable) {
            Toast.makeText(this, "ÏÇ¨ÏßÑ Ï§ÄÎπÑ Ï§ë Ïò§Î•ò", Toast.LENGTH_SHORT).show()
            null
        }
        return dtoPart to filePart
    }
    private fun submitUpdate(boardId: Long) {
        Log.d("UPDATETEST" , "ÏàòÏ†ï Î≤ÑÌäº ÏßÑÏûÖ")

        if (boardId <= 0) {
            Toast.makeText(this, "ÏûòÎ™ªÎêú Í≤åÏãúÍ∏Ä ID", Toast.LENGTH_SHORT).show(); return
        }

        val (dtoPart, filePart) = buildUpdatePayload()

        api.updateBoard( dtoPart, filePart)
            .enqueue(object : retrofit2.Callback<BoardData> {
                override fun onResponse(
                    call: retrofit2.Call<BoardData>,
                    res: retrofit2.Response<BoardData>
                ) {
                    if (res.isSuccessful) {
                        val updated = res.body()
                        val data = Intent().apply {
                            putExtra(Constants.EXTRA_BOARD_DATA, updated)
                            putExtra(Constants.EXTRA_BOARD_ID, updated?.idx ?: editingBoardId)
                        }
                        setResult(Activity.RESULT_OK, data)
                        Toast.makeText(this@LostWriteActivity, "ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.", Toast.LENGTH_SHORT).show()
                        Log.d("UPDATETEST" , "ÏàòÏ†ïÏôÑÎ£å")
                        finish()

                    } else {
                        Toast.makeText(this@LostWriteActivity, "ÏàòÏ†ï Ïã§Ìå®: ${res.code()}", Toast.LENGTH_SHORT).show()
                        Log.d("UPDATETEST" , "ÏàòÏ†ï Ïã§Ìå®")
                    }
                }
                override fun onFailure(call: retrofit2.Call<BoardData>, t: Throwable) {
                    Toast.makeText(this@LostWriteActivity, "ÌÜµÏã† Ïò§Î•ò: ${t.message}", Toast.LENGTH_SHORT).show()
                    Log.d("UPDATETEST" , "ÌÜµÏã† Ïò§Î•ò")
                }
            })
    }
}
